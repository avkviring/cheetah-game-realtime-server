# Интеграция автоскейлинга Agones в кластер

## Проблема

Agones сейчас не поддерживает backfill операции.
Если для аллокации Relay использовать только Agones API, то на одном сервере будет только одна битва,
т.к. на каждый вызов Allocation, Agones будет брать новый Ready Relay и переводить его в статус Allocated.

На самом деле в Agones есть alpha фича [Player Tracking](https://agones.dev/site/docs/integration-patterns/high-density-gameservers/),
но она требует отправки в Agones ID всех подключенных игроков. Т.к. мы планируем 200к игроков онлайн, это не выглядит хорошо масштабируемым.

Нам это не подходит, т.к. архитектура должна поддерживать 10к битв.

## Решение

Для управления жизненным циклом сервера в agones нужен сервис, который будет выбирать какой Relay использовать для новой битвы.
Назовем его Registry.

Registry будет хранить адреса Relay серверов на которых можно создавать битвы.

Relay будут уведомлять Registry о своем статусе: Ready, NotReady, Allocated

Factory будет отправлять запрос с деталями битвы в Registry и получит в ответ адрес Relay на котором будет запущена битва.
Registry выберет наиболее подходящий сервер по своей логике.

Отдельно от Registry будет работать Agones FleetAutoscaler, который будет поддерживать буфер Ready Relay,
чтобы при приходе новых игроков всегда быстро нашелся Relay для новой битвы

## High-Level Design

Будет два типа запросов:
* Factory -> Registry запрос на получение подходящего Relay
* Relay -> Registry уведомление Registry о существовании и текущем статусе Relay

Для упрощения поддержки и масштабирования стоит сделать сервис Registry группой stateless серверов.

При rollout registry на новую версию нужно обеспечить сохранность данных: состояний всех активных Relay.
Для этого можно использовать отдельное хранилище (подробности ниже).

### Другие опции

* Relay обновляют свой статус напрямую в бд.
  Минус в том, что Relay будет знать о внутреннем формате хранения бд Registry.

## API

Для взаимодействия с другими сервисами Relay должен использовать internal GRPC

### Relay -> Registry

Relay должен отправлять все изменения своего состояния в Registry
При использовании Unary RPC возникает вопрос, как узнать что Relay упал.
Перед выключением Relay должен отправить статус NotReady, чтобы Registry удалил его из хранилища.
При разрыве соединения Relay должен переподключиться к Registry (возможно к другому инстансу)
и продолжить обновлять свой статус.

В будущем в RelayStatusUpdate могут понадобится дополнительные поля для кастомизации логики Registry, например
версия Relay сервера, нагрузка на Relay.

### Factory -> Registry

Factory получает запросы от Matchmaking на создание матча.
Factory запрашивает у Registry сервер на котором он будет создавать матчи.
Registry выбирает наиболее подходящий сервер среди списка известных и возвращает адрес в Factory

Схема уже описана в [matches.registry.internal.proto](../../../proto/matches/Registry/matches.registry.internal.proto)

## Внутреннее устройство Registry

Для выбора подходящего Relay сервера Registry должен иметь актуальный список Relay серверов и данные о их загрузке.
Возможны 2 подхода:
1. Registry ничего не хранит в памяти и на каждый FindFreeRelayRequest читает данные всех Relay из БД
2. Registry хранит данные в памяти и не запрашивает БД на каждый запрос FindFreeRelayRequest.
   Для этого нужен механизм обновления от БД к каждому инстансу Registry.

Для начальной реализации можно остановиться на первом варианте, т.к. он проще.

### Логика выбора

Чтобы обеспечить backfill Registry должен возвращать в первую очередь адреса Allocated Relay серверов.
Если Allocated серверов нет, Registry вернет Ready Relay сервер. При создании битвы Relay обновит свой статус на Allocated.
Если Allocated Relay сервер полон, он может отправить NotReady статус в Registry.
Если Ready серверов тоже нет, то сломался автоскейлинг и мы не сможем создавать новые битвы.

### Хранилище

Списки Relay серверов можно хранить в двух set в redis: для Allocated и Ready серверов.

## Консистентность

* При краше Registry сервера, все подключенные Relay подключаться к другому Registry и продолжат обновлять данные как обычно.
* При выключении Relay сервера, Relay удалит данные об этом Relay из Registry, отправив NotReady
  Если потеря соединения была временной, Relay подключится к другому Registry.
  Если Relay упал, то его адрес останется в хранилище. Чтобы не возвращать адрес несуществующего Relay,
  Registry перед возвращением адреса Relay пробует к нему подключиться. Если Relay недоступен, Registry удаляет его из хранилища
  и пробует получить новый адрес из хранилища.

## Scaling

Если мы планируем 10к битв, то у нас будет 100-1000 Relay серверов.

Registry сервера stateless и мы можем запустить их очень много.
Registry получает адрес Relay серверов командой srandmember, которая не зависит от количества адресов в set.
При необходимости можно запустить Redis кластер с репликацией.
